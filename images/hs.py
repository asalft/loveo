import osimport jsonimport asyncioimport tempfileimport signalimport randomimport globfrom telethon import TelegramClientfrom telethon.sessions import StringSessionfrom telethon.errors import SessionPasswordNeededError, PhoneCodeInvalidErrorfrom telethon.tl.functions.photos import UploadProfilePhotoRequest, DeletePhotosRequestfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkupfrom telegram.ext import (    ApplicationBuilder,    CommandHandler,    CallbackQueryHandler,    ConversationHandler,    MessageHandler,    ContextTypes,    filters,)# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ---BOT_TOKEN = os.environ.get("BOT_TOKEN")OWNER_ID = int(os.environ.get("OWNER_ID", 0))API_ID = int(os.environ.get("API_ID", 0))API_HASH = os.environ.get("API_HASH")SESSION_STORE = os.environ.get("SESSION_STORE", "./sessions.json")PHOTO_FOLDER = "photos"CHANGE_INTERVAL = 300  # Ø«ÙˆØ§Ù†ÙŠAWAIT_PHONE, AWAIT_CODE, AWAIT_PASS, AWAIT_PHOTO, AWAIT_SESSION = range(5)clients = {}# --- ØªØ­Ù…ÙŠÙ„ ÙˆØ­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø§Øª ---def load_sessions():    try:        with open(SESSION_STORE, "r", encoding="utf-8") as f:            return json.load(f)    except:        return {}def save_sessions(sessions):    with open(SESSION_STORE, "w", encoding="utf-8") as f:        json.dump(sessions, f, ensure_ascii=False, indent=2)# --- Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… ---def main_menu():    kb = [        [InlineKeyboardButton("ğŸ” ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ", callback_data="login"),         InlineKeyboardButton("ğŸ”‘ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø¬Ù„Ø³Ø©", callback_data="login_session")],        [InlineKeyboardButton("ğŸ“¸ ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¢Ù†", callback_data="change_photo")],        [InlineKeyboardButton("â›” ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬", callback_data="logout")],    ]    return InlineKeyboardMarkup(kb)# --- Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ ---async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):    if update.effective_user.id != OWNER_ID:        await update.message.reply_text("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·.")        return    await update.message.reply_text("Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø§Ù„Ø£Ø³ÙÙ„ ğŸ‘‡", reply_markup=main_menu())# --- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± ---async def callback_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):    q = update.callback_query    await q.answer()    uid = update.effective_user.id    if uid != OWNER_ID:        await q.edit_message_text("ğŸš« ØºÙŠØ± Ù…ØµØ±Ø­.")        return    if q.data == "login":        await q.edit_message_text("ğŸ“ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø§Ù„Ø¢Ù† (Ù…Ø«Ø§Ù„: +201234567890):")        return AWAIT_PHONE    elif q.data == "login_session":        await q.edit_message_text("ğŸ“¨ Ø£Ø±Ø³Ù„ **String Session** Ù‡Ù†Ø§:")        return AWAIT_SESSION    elif q.data == "change_photo":        await q.edit_message_text("ğŸ“¸ Ø£Ø±Ø³Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¢Ù† (ØµÙˆØ±Ø© Ø£Ùˆ Ù…Ù„Ù ØµÙˆØ±Ø©).")        return AWAIT_PHOTO    elif q.data == "logout":        sessions = load_sessions()        sid = str(uid)        if sid in sessions:            try:                entry = clients.pop(uid, None)                if entry:                    await entry["client"].disconnect()                sessions.pop(sid)                save_sessions(sessions)                await q.edit_message_text("âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ø¨Ù†Ø¬Ø§Ø­.")            except Exception as e:                await q.edit_message_text(f"âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬: {e}")        else:            await q.edit_message_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø© Ù…Ø­ÙÙˆØ¸Ø©.")    else:        await q.edit_message_text("â“ Ø®ÙŠØ§Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ.")# --- ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ---async def receive_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):    uid = update.effective_user.id    phone = update.message.text.strip()    client = TelegramClient(StringSession(), API_ID, API_HASH)    await client.connect()    try:        await client.send_code_request(phone)        context.user_data["client"] = client        context.user_data["phone"] = phone        await update.message.reply_text("ğŸ“¨ ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨ÙƒØŒ Ø£Ø±Ø³Ù„Ù‡ Ù‡Ù†Ø§:")        return AWAIT_CODE    except Exception as e:        await update.message.reply_text(f"âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯: {e}")        await client.disconnect()        return ConversationHandler.ENDasync def receive_code(update: Update, context: ContextTypes.DEFAULT_TYPE):    code = update.message.text.strip()    client: TelegramClient = context.user_data.get("client")    phone = context.user_data.get("phone")    try:        await client.sign_in(phone=phone, code=code)    except SessionPasswordNeededError:        await update.message.reply_text("ğŸ”’ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø­Ù…ÙŠ Ø¨ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± (2FA)ØŒ Ø£Ø±Ø³Ù„Ù‡Ø§ Ø§Ù„Ø¢Ù†:")        return AWAIT_PASS    except PhoneCodeInvalidError:        await update.message.reply_text("âŒ Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹.")        await client.disconnect()        return ConversationHandler.END    me = await client.get_me()    session_str = client.session.save()    sessions = load_sessions()    sessions[str(update.effective_user.id)] = {"session": session_str}    save_sessions(sessions)    clients[update.effective_user.id] = {"client": client, "me": me.to_dict()}    await update.message.reply_text(f"âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰: {me.first_name}", reply_markup=main_menu())    return ConversationHandler.ENDasync def receive_pass(update: Update, context: ContextTypes.DEFAULT_TYPE):    password = update.message.text.strip()    client: TelegramClient = context.user_data.get("client")    await client.sign_in(password=password)    me = await client.get_me()    session_str = client.session.save()    sessions = load_sessions()    sessions[str(update.effective_user.id)] = {"session": session_str}    save_sessions(sessions)    clients[update.effective_user.id] = {"client": client, "me": me.to_dict()}    await update.message.reply_text(f"âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰: {me.first_name}", reply_markup=main_menu())    return ConversationHandler.END# --- ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± String Session ---async def receive_session(update: Update, context: ContextTypes.DEFAULT_TYPE):    uid = update.effective_user.id    session_str = update.message.text.strip()    client = TelegramClient(StringSession(session_str), API_ID, API_HASH)    await client.connect()    try:        me = await client.get_me()        sessions = load_sessions()        sessions[str(uid)] = {"session": session_str}        save_sessions(sessions)        clients[uid] = {"client": client, "me": me.to_dict()}        await update.message.reply_text(f"âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰: {me.first_name}", reply_markup=main_menu())    except Exception as e:        await update.message.reply_text(f"âŒ ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„: {e}")        await client.disconnect()    return ConversationHandler.END# --- Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„ØµÙˆØ± ÙˆØªØºÙŠÙŠØ±Ù‡Ø§ ÙÙˆØ±Ù‹Ø§ ---async def receive_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):    uid = update.effective_user.id    sessions = load_sessions()    sess = sessions.get(str(uid))    if not sess:        await update.message.reply_text("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„. Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹.")        return ConversationHandler.END    client = clients.get(uid, {}).get("client")    if not client:        client = TelegramClient(StringSession(sess["session"]), API_ID, API_HASH)        await client.connect()        clients[uid] = {"client": client}    if not await client.is_connected():        await client.connect()    tmp_dir = tempfile.gettempdir()    files = []    if update.message.photo:        f = os.path.join(tmp_dir, f"{uid}_photo.jpg")        await update.message.photo[-1].get_file().download(custom_path=f)        files.append(f)    elif update.message.document and update.message.document.mime_type.startswith("image/"):        f = os.path.join(tmp_dir, update.message.document.file_name)        await update.message.document.get_file().download(custom_path=f)        files.append(f)    else:        await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø£Ùˆ Ù…Ù„Ù ØµÙˆØ±Ø©.")        return ConversationHandler.END    for path in files:        try:            photos = await client.get_profile_photos('me')            if photos.total > 0:                await client(DeletePhotosRequest(photos[:]))            uploaded = await client.upload_file(path)            await client(UploadProfilePhotoRequest(uploaded))            await update.message.reply_text("âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ© Ø¨Ù†Ø¬Ø§Ø­.")        except Exception as e:            await update.message.reply_text(f"âš ï¸ ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©: {e}")        finally:            try:                os.remove(path)            except:                pass    return ConversationHandler.END# --- Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ØµÙˆØ± ---async def auto_change_photos():    await asyncio.sleep(10)    print("ğŸ” Ø¨Ø¯Ø£ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ...")    while True:        try:            if not clients:                await asyncio.sleep(CHANGE_INTERVAL)                continue            for uid, entry in clients.items():                client = entry["client"]                if not await client.is_connected():                    await client.connect()                photo_files = glob.glob(os.path.join(PHOTO_FOLDER, "*"))                if not photo_files:                    print("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ± ÙÙŠ Ù…Ø¬Ù„Ø¯ photos/")                    await asyncio.sleep(CHANGE_INTERVAL)                    continue                chosen = random.choice(photo_files)                try:                    photos = await client.get_profile_photos('me')                    if photos.total > 0:                        await client(DeletePhotosRequest(photos[:]))                    uploaded = await client.upload_file(chosen)                    await client(UploadProfilePhotoRequest(uploaded))                    print(f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©: {chosen}")                except Exception as e:                    print(f"âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: {e}")            await asyncio.sleep(CHANGE_INTERVAL)        except Exception as e:            print(f"âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: {e}")            await asyncio.sleep(CHANGE_INTERVAL)# --- Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø§Øª ---async def shutdown_clients():    for entry in clients.values():        c = entry.get("client")        if c:            try:                await c.disconnect()            except:                pass    clients.clear()# --- Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ---def build_conversation():    return ConversationHandler(        entry_points=[CallbackQueryHandler(callback_query_handler)],        states={            AWAIT_PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_phone)],            AWAIT_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_code)],            AWAIT_PASS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_pass)],            AWAIT_PHOTO: [MessageHandler(filters.PHOTO | filters.Document.IMAGE, receive_photo)],            AWAIT_SESSION: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_session)],        },        fallbacks=[],        allow_reentry=True,    )# --- Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ---def main():    if not BOT_TOKEN or not API_ID or not API_HASH or not OWNER_ID:        print("âš ï¸ ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯ BOT_TOKEN Ùˆ API_ID Ùˆ API_HASH Ùˆ OWNER_ID.")        return    app = ApplicationBuilder().token(BOT_TOKEN).build()    app.add_handler(CommandHandler("start", start))    app.add_handler(build_conversation())    loop = asyncio.get_event_loop()    def stop_signal_handler(*_):        print("ğŸ›‘ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª...")        loop.create_task(shutdown_clients())        loop.stop()    signal.signal(signal.SIGTERM, stop_signal_handler)    signal.signal(signal.SIGINT, stop_signal_handler)    # ØªØ´ØºÙŠÙ„ Ù…Ù‡Ù…Ø© Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø§Ù„ØªÙˆØ§Ø²ÙŠ    loop.create_task(auto_change_photos())    print("ğŸ¤– Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†...")    app.run_polling()if __name__ == "__main__":    main()